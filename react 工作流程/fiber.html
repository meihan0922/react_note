<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="root">
      <div id="A1">
        <div id="B1">
          <div id="C1"></div>
          <div id="C2"></div>
        </div>
        <div id="B2"></div>
      </div>
    </div>
  </body>
  <script>
    //   <div id="A1">
    //     <div id="B1">
    //       <div id="C1"></div>
    //       <div id="C2"></div>
    //     </div>
    //     <div id="B2"></div>
    //   </div>

    let container = document.getElementById("root");
    let C1 = { type: "div", key: "C1", props: { id: "C1", children: [] } };
    let C2 = { type: "div", key: "C2", props: { id: "C2", children: [] } };
    let B1 = {
      type: "div",
      key: "B1",
      props: { id: "B1", children: [C1, C2] },
    };
    let B2 = { type: "div", key: "B2", props: { id: "B2", children: [] } };
    let A1 = {
      type: "div",
      key: "A1",
      props: { id: "A1", children: [B1, B2] },
    };

    let workInProgressRoot = null;
    // 下一個要處理的單元
    let nextUnitWork = workInProgressRoot;
    // 對應 diff 結果是要替換
    const PLACEMEMT = "PLACEMEMT";
    // 工作循環
    function workloop(deadline) {
      // 2. 開始工作！
      // 如果當前處理的節點存在，而且還有剩餘的時間
      // 就去構建 下一個 fiber node
      // 上圖綠色線條
      while (nextUnitWork && deadline.timeRemaing() > 0) {
        nextUnitWork = performUnitWork(nextUnitWork);
      }
      // 5. 如果沒有下一個節點了，進入第二階段 commit
      // 上圖的藍色線
      if (!nextUnitWork) {
        commitRoot();
      }
    }
    // 構建 fiber tree
    function performUnitWork(workInProgressFiber) {
      // 4. 創建 dom節點
      startWork(fiber);
      // 如果有子節點優先處理子節點，以『深度優先』
      if (fiber.child) {
        return fiber.child;
      }
      // 如果沒有子節點
      while (fiber) {
        // 此節點已經完成
        completeUnitOfWork(fiber); //可以结束此fiber的渲染了
        // 檢查是否有兄弟節點
        if (fiber.sibling) {
          return fiber.sibling;
        }
        fiber = fiber.return; // 回到父層級，再去找父的兄弟節點
      }
    }
    function startWork(deadline) {
      // 創件 dom
      console.log("beginWork", fiber.key);
      //fiber.stateNode = document.createElement(fiber.type);
    }
    // 1. 請求瀏覽器分配時間 requestIdleCallback，只要有時間就會去執行 workloop;
    requestIdleCallback(workLoop, { timeout: 1000 });
  </script>
</html>
